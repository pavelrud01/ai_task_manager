"""
Утилиты для отслеживания стандартов в артефактах
"""

import hashlib
from pathlib import Path
from typing import Dict, Any, Optional
from datetime import datetime


def add_standard_metadata(
    data: Dict[str, Any], 
    step_name: str, 
    standard_text: str = "",
    standard_path: Optional[Path] = None,
    context: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Добавляет метаданные стандарта в артефакт.
    
    Args:
        data: Основные данные артефакта
        step_name: Имя шага
        standard_text: Текст стандарта
        standard_path: Путь к файлу стандарта
        context: Контекст выполнения
    
    Returns:
        Обновленные данные с метаданными
    """
    metadata = {
        "standard_id": f"{step_name}_standard",
        "source_path": str(standard_path) if standard_path else "",
        "fingerprint": _calculate_fingerprint(standard_text),
        "timestamp": datetime.now().isoformat(),
        "step_name": step_name
    }
    
    # Добавляем информацию о модели, если доступна
    if context:
        metadata.update({
            "model_name": context.get("MODEL_NAME", ""),
            "run_id": context.get("run_id", ""),
            "project_id": context.get("project_id", "")
        })
    
    # Добавляем метаданные в корень данных
    data["__metadata"] = metadata
    
    return data


def _calculate_fingerprint(text: str) -> str:
    """Вычисляет SHA256 отпечаток текста стандарта."""
    if not text:
        return ""
    return hashlib.sha256(text.encode('utf-8')).hexdigest()


def get_standard_metadata(data: Dict[str, Any]) -> Dict[str, Any]:
    """Извлекает метаданные стандарта из артефакта."""
    return data.get("__metadata", {})


def validate_standard_consistency(
    artifact_data: Dict[str, Any], 
    current_standard_text: str
) -> Dict[str, Any]:
    """
    Проверяет консистентность стандарта в артефакте.
    
    Returns:
        Dict с результатами проверки
    """
    metadata = get_standard_metadata(artifact_data)
    stored_fingerprint = metadata.get("fingerprint", "")
    current_fingerprint = _calculate_fingerprint(current_standard_text)
    
    return {
        "is_consistent": stored_fingerprint == current_fingerprint,
        "stored_fingerprint": stored_fingerprint,
        "current_fingerprint": current_fingerprint,
        "standard_id": metadata.get("standard_id", ""),
        "source_path": metadata.get("source_path", ""),
        "timestamp": metadata.get("timestamp", "")
    }


def create_human_readable_export(
    artifact_data: Dict[str, Any], 
    step_name: str,
    output_dir: Path
) -> Path:
    """
    Создает человеко-читаемую версию артефакта.
    
    Args:
        artifact_data: Данные артефакта
        step_name: Имя шага
        output_dir: Директория для сохранения
    
    Returns:
        Путь к созданному файлу
    """
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Создаем имя файла
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{step_name}_HUMAN_READABLE.md"
    output_path = output_dir / filename
    
    # Извлекаем метаданные
    metadata = get_standard_metadata(artifact_data)
    
    # Создаем markdown контент
    content = f"""# {step_name.upper()} - Human Readable Export

## Metadata
- **Standard ID**: {metadata.get('standard_id', 'N/A')}
- **Source Path**: {metadata.get('source_path', 'N/A')}
- **Fingerprint**: {metadata.get('fingerprint', 'N/A')[:16]}...
- **Timestamp**: {metadata.get('timestamp', 'N/A')}
- **Model**: {metadata.get('model_name', 'N/A')}
- **Run ID**: {metadata.get('run_id', 'N/A')}

## Data Summary
- **Total Fields**: {len(artifact_data)}
- **Data Keys**: {', '.join(k for k in artifact_data.keys() if not k.startswith('__'))}

## Full Data
```json
{json.dumps(artifact_data, indent=2, ensure_ascii=False)}
```

---
*Generated by AI Marketing Agent*
*Timestamp: {datetime.now().isoformat()}*
"""
    
    # Сохраняем файл
    output_path.write_text(content, encoding='utf-8')
    
    return output_path


def add_standard_tracking_to_step_result(
    step_result: 'StepResult',
    step_name: str,
    standard_text: str = "",
    standard_path: Optional[Path] = None,
    context: Optional[Dict[str, Any]] = None
) -> 'StepResult':
    """
    Добавляет отслеживание стандартов к результату шага.
    
    Args:
        step_result: Результат шага
        step_name: Имя шага
        standard_text: Текст стандарта
        standard_path: Путь к стандарту
        context: Контекст выполнения
    
    Returns:
        Обновленный результат шага
    """
    # Добавляем метаданные к данным
    updated_data = add_standard_metadata(
        step_result.data, 
        step_name, 
        standard_text, 
        standard_path, 
        context
    )
    
    # Создаем новый StepResult с обновленными данными
    from workflow.steps.base import StepResult
    return StepResult(
        data=updated_data,
        score=step_result.score,
        uncertainty=step_result.uncertainty,
        notes=step_result.notes,
        rollback_to=step_result.rollback_to
    )

